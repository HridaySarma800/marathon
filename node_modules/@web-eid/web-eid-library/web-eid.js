/*
 * Copyright (c) 2020-2023 Estonian Information System Authority
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import Action from "./models/Action";
import ErrorCode from "./errors/ErrorCode";
import MissingParameterError from "./errors/MissingParameterError";
import WebExtensionService from "./services/WebExtensionService";
import config from "./config";
import sleep from "./utils/sleep";
const webExtensionService = new WebExtensionService();
const initializationTime = +new Date();
/**
 * Give browsers a moment to load the content script
 */
async function extensionLoadDelay() {
    const now = +new Date();
    await sleep(initializationTime + config.MAX_EXTENSION_LOAD_DELAY - now);
}
export async function status() {
    await extensionLoadDelay();
    const timeout = config.EXTENSION_HANDSHAKE_TIMEOUT + config.NATIVE_APP_HANDSHAKE_TIMEOUT;
    const message = {
        action: Action.STATUS,
        libraryVersion: config.VERSION,
    };
    try {
        const { library, extension, nativeApp, } = await webExtensionService.send(message, timeout);
        return {
            library,
            extension,
            nativeApp,
        };
    }
    catch (error) {
        error.library = config.VERSION;
        throw error;
    }
}
export async function authenticate(challengeNonce, options) {
    await extensionLoadDelay();
    if (!challengeNonce) {
        throw new MissingParameterError("authenticate function requires a challengeNonce");
    }
    const timeout = (config.EXTENSION_HANDSHAKE_TIMEOUT +
        config.NATIVE_APP_HANDSHAKE_TIMEOUT +
        ((options === null || options === void 0 ? void 0 : options.userInteractionTimeout) || config.DEFAULT_USER_INTERACTION_TIMEOUT));
    const message = {
        action: Action.AUTHENTICATE,
        libraryVersion: config.VERSION,
        challengeNonce,
        options,
    };
    const { unverifiedCertificate, algorithm, signature, format, appVersion, } = await webExtensionService.send(message, timeout);
    return {
        unverifiedCertificate,
        algorithm,
        signature,
        format,
        appVersion,
    };
}
export async function getSigningCertificate(options) {
    await extensionLoadDelay();
    const timeout = (config.EXTENSION_HANDSHAKE_TIMEOUT +
        config.NATIVE_APP_HANDSHAKE_TIMEOUT +
        ((options === null || options === void 0 ? void 0 : options.userInteractionTimeout) || config.DEFAULT_USER_INTERACTION_TIMEOUT) * 2);
    const message = {
        action: Action.GET_SIGNING_CERTIFICATE,
        libraryVersion: config.VERSION,
        options,
    };
    const { certificate, supportedSignatureAlgorithms, } = await webExtensionService.send(message, timeout);
    return {
        certificate,
        supportedSignatureAlgorithms,
    };
}
export async function sign(certificate, hash, hashFunction, options) {
    await extensionLoadDelay();
    if (!certificate) {
        throw new MissingParameterError("sign function requires a certificate as parameter");
    }
    if (!hash) {
        throw new MissingParameterError("sign function requires a hash as parameter");
    }
    if (!hashFunction) {
        throw new MissingParameterError("sign function requires a hashFunction as parameter");
    }
    const timeout = (config.EXTENSION_HANDSHAKE_TIMEOUT +
        config.NATIVE_APP_HANDSHAKE_TIMEOUT +
        ((options === null || options === void 0 ? void 0 : options.userInteractionTimeout) || config.DEFAULT_USER_INTERACTION_TIMEOUT) * 2);
    const message = {
        action: Action.SIGN,
        libraryVersion: config.VERSION,
        certificate,
        hash,
        hashFunction,
        options,
    };
    const { signature, signatureAlgorithm, } = await webExtensionService.send(message, timeout);
    return {
        signature,
        signatureAlgorithm,
    };
}
export { Action, ErrorCode };
export { config };
//# sourceMappingURL=web-eid.js.map