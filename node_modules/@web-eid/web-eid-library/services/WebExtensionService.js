/*
 * Copyright (c) 2020-2023 Estonian Information System Authority
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import Action from "../models/Action";
import ActionPendingError from "../errors/ActionPendingError";
import ActionTimeoutError from "../errors/ActionTimeoutError";
import ContextInsecureError from "../errors/ContextInsecureError";
import ExtensionUnavailableError from "../errors/ExtensionUnavailableError";
import config from "../config";
import { deserializeError } from "../utils/errorSerializer";
export default class WebExtensionService {
    constructor() {
        this.loggedWarnings = [];
        this.queue = [];
        window.addEventListener("message", (event) => this.receive(event));
    }
    receive(event) {
        var _a, _b, _c, _d, _e, _f;
        if (!/^web-eid:/.test((_a = event.data) === null || _a === void 0 ? void 0 : _a.action))
            return;
        const message = event.data;
        const suffix = (_c = (_b = message.action) === null || _b === void 0 ? void 0 : _b.match(/success$|failure$|ack$/)) === null || _c === void 0 ? void 0 : _c[0];
        const initialAction = this.getInitialAction(message.action);
        const pending = this.getPendingMessage(initialAction);
        if (message.action === Action.WARNING) {
            (_d = message.warnings) === null || _d === void 0 ? void 0 : _d.forEach((warning) => {
                if (!this.loggedWarnings.includes(warning)) {
                    this.loggedWarnings.push(warning);
                    console.warn(warning.replace(/\n|\r/g, ""));
                }
            });
        }
        else if (pending) {
            switch (suffix) {
                case "ack": {
                    clearTimeout(pending.ackTimer);
                    break;
                }
                case "success": {
                    this.removeFromQueue(initialAction);
                    (_e = pending.resolve) === null || _e === void 0 ? void 0 : _e.call(pending, message);
                    break;
                }
                case "failure": {
                    const failureMessage = message;
                    this.removeFromQueue(initialAction);
                    (_f = pending.reject) === null || _f === void 0 ? void 0 : _f.call(pending, failureMessage.error ? deserializeError(failureMessage.error) : failureMessage);
                    break;
                }
            }
        }
    }
    send(message, timeout) {
        if (this.getPendingMessage(message.action)) {
            return Promise.reject(new ActionPendingError());
        }
        else if (!window.isSecureContext) {
            return Promise.reject(new ContextInsecureError());
        }
        else {
            const pending = { message };
            this.queue.push(pending);
            pending.promise = new Promise((resolve, reject) => {
                pending.resolve = resolve;
                pending.reject = reject;
            });
            pending.ackTimer = window.setTimeout(() => this.onAckTimeout(pending), config.EXTENSION_HANDSHAKE_TIMEOUT);
            pending.replyTimer = window.setTimeout(() => this.onReplyTimeout(pending), timeout);
            window.postMessage(message, "*");
            return pending.promise;
        }
    }
    onReplyTimeout(pending) {
        var _a;
        this.removeFromQueue(pending.message.action);
        (_a = pending.reject) === null || _a === void 0 ? void 0 : _a.call(pending, new ActionTimeoutError());
    }
    onAckTimeout(pending) {
        var _a;
        clearTimeout(pending.replyTimer);
        this.removeFromQueue(pending.message.action);
        (_a = pending.reject) === null || _a === void 0 ? void 0 : _a.call(pending, new ExtensionUnavailableError());
    }
    getPendingMessage(action) {
        return this.queue.find((pm) => {
            return pm.message.action === action;
        });
    }
    getInitialAction(action) {
        return action.replace(/-success$|-failure$|-ack$/, "");
    }
    removeFromQueue(action) {
        const pending = this.getPendingMessage(action);
        clearTimeout(pending === null || pending === void 0 ? void 0 : pending.replyTimer);
        this.queue = this.queue.filter((pending) => (pending.message.action !== action));
    }
}
//# sourceMappingURL=WebExtensionService.js.map